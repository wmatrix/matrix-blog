<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wmatrix World</title>
    <link>https://wmatrix.github.io/</link>
    <description>Recent content on Wmatrix World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018. A.R. Reserved.</copyright>
    <lastBuildDate>Thu, 08 Mar 2018 20:37:44 +0800</lastBuildDate>
    
	<atom:link href="https://wmatrix.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Visual Studio开发工具笔记</title>
      <link>https://wmatrix.github.io/post/visual-studio%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 08 Mar 2018 20:37:44 +0800</pubDate>
      
      <guid>https://wmatrix.github.io/post/visual-studio%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/</guid>
      <description>最近使用Visual Studio 2017进行项目的开发，不得不为微软的这款IDE点赞一下，确实提高了工作了效率和减轻了开发负担。不过因为并不熟练，在使用的过程中难免遇上一些问题，本文对于遇到的这些问题及对应的解决方案进行记录，分享与以备后查。
其实在解决问题时，很多时候也是通过百度搜索来寻求答案的，只是发现很多的结果都是复制粘贴的，此外也比较过时，因此自行总结这个过程也是利己利人的必要工作。我将这些笔记称之为Better Practice系列。
BP-项目组织 Solution &amp;amp; Project 以前虽然也接触过VS的Solution和Project的概念，但是并没有实际在项目中应用过，因而也就没什么印象。但是最近半年多的VS开发经历让我对这两个概念有了一种相见恨晚的感觉，觉得非常的实用。之前在Linux平台下的开发主要实用Makefile来构建管理项目，对于多个项目的管理和依赖组织非常灵活，要求对Makefile非常熟练方能安全实现这一目标，但是在VS中，Solution，Project和Reference的引入不仅让项目组织一目了然，而且并不需要开发者学习掌握太多的技术基础就能做到，非常高效。
随便找一个开源的项目如dlib,opencv,opencl等，打开VS的解决方案，就可以直观地管理所有的项目资源，不限于代码文件，项目配置，资源文件，平台部署等等，如图：
如果我们用Makefile来编写管理的话，将会是很长很长的规则，因此可视化GUI有其很有用的一方面。这里的要点是：
 任何项目都是某个问题的解决方案，所以解决方案是总纲 一个解决方案可以由多个项目组成，这些项目组成一个统一完整的整体 解决方案内的项目之间可以相互引用，VS中甚至可以创建共享项目来实现目标，库，也可以共享代码 项目的目标可以是一个静态库，动态库，可执行文件，或者只是一份共享代码，从而可以跨平台引用维护 你可以随时在解决方案中新建项目进行测试，或者是添加现有项目进行管理，或者是移除无用的项目  版本管理 一个没有版本管理的项目是不能成为一个可持续和产品级应用的，熟悉版本管理的流程和至少一个版本管理工具是每一个软件开发人员的必需技能之一。日常工作开发中使用最广的版本管理工具有svn和git, 它们刚好代表集中式和分布式两类版本管理开发流程，各有利弊。最近几年由于Github的流行，git版本工具好像越来越需要程序员进行掌握使用了。
VS中集成了源码版本管理流程需要的一整套操作，你可以无缝简单地整合现有的版本管理工具，或者是初始化版本库进行版本管理开发。在VS的右下角位置有版本管理的初始化，分支和修改记录操作及信息，你可以直接点击进行查看和操作，如图： 点击分支名称后，可以查看当前分支对应的历史提交记录，如图： 更多的操作可以通过团队资源管理器进行操作：
团队开发 在大型项目的开发中，团队分工协作是项目成功完成的基础。除了版本管理可以保证项目开发的可回溯性和代码安全性外，团队协作开发的同步合并和代码审核工作也是保证项目质量和进度的必须工作。VS工具集成了团队协作开发的流程，你可以登录自己的Microsoft账户来同步自身的个性化设置，项目信息和版本管理，你还可以连接到Visual Studio Team Services来实现自动构建和发布流程，你需要的全部都提供好了： 团队开发的要点是：
 首先创建你的开发账号，你可以使用Microsoft旗下的任何账号信息，如hotmail邮箱账号，outlook邮箱账号，azure账号等等，登录VS进行同步 加入项目开发团队，分配好团队各个开发成员的角色和工作任务，这些都可以在Team Services中完成 使用版本管理团队的代码提交，审核代码质量，自动构建确保代码的完整性和可用性 Visual Studio Team Services是与GitHub类似的开发服务，只要熟悉GitHub的流程，那么对于Team Services肯定能快速上手，而且它可能更强大和易用，毕竟大部分功能是需要购买的  BP-项目配置 配置管理器：配置与平台 项目开发一般而言会涉及到debug和release两种配置，分别用来作为项目调试和产品发布的配置使用；此外对于当前越来越多的异构计算平台，项目可能需要针对不同的平台分别进行特定的优化或者实现，因而需要针对不同的平台进行构建，当前最常见的平台有win32(x86),x64,arm,分别对应PC和移动端或者嵌入式端的计算平台。
VS中的配置管理器模块完美地解决了项目配置和平台管理的这一问题，但是在使用时有一些注意事项或者说是不良习惯需要规范。关于Debug和Release两类配置：
 Debug配置和Release配置中的各项属性是完全独立的，因此包含目录，库目录，库链接，环境参数，工作目录等等，你需要配置两次来实现构建 Debug配置构建中使用的链接库应该也是debug构建出来的，Release配置构建中使用的链接库应该是release构建出来的，不要混用 Debug配置构建出来的应用性能会比Release构建出来的性能相差巨大，甚至差高达10倍以上，因此请不要在Debug中过早地考虑性能优化问题 Debug配置与Release配置出来的库如果进行混用的话，可能会出现各种莫名奇怪的问题，也可能运行正常，有问题时请检查配置匹配问题  这些都是我在项目开发中出现问题时才学会的教训，在使用SeetaFaceEngine人脸识别库的过程中，因为在Debug配置中使用release出来的库，出现接口调用正常但是结果不正确的异常；更换成debug出来的库后，结果正常了，但是性能相差高达10倍以上，这给了我深刻的印象。
关于构建平台的话，因为不同的平台二进制是不兼容的，因而不会出现混用而成功构建的问题。
头文件及链接库目录配置：No Such File问题 添加项目搜寻头文件和链接库目录的配置有两处位置可以实现，都在项目属性配置对话框中，一处是【VC++目录】：
另一处是【C/C++ - 常规 - 附加包含目录】：
和【连接器 - 常规 - 附加库目录】：
链接库文件：无法解析的符号问题 在项目构建中出现无法解析的符号问题时，要么是没有添加需要的库输入进行链接，要么就是对应的符号所在的源文件并未导入一起构建。你可以在【连接器 - 输入 - 附件依赖项】添加依赖库：</description>
    </item>
    
    <item>
      <title>Orangepi Pc Plus 研究笔记</title>
      <link>https://wmatrix.github.io/post/orangepi-pc-plus-note/</link>
      <pubDate>Sun, 11 Feb 2018 11:27:31 +0800</pubDate>
      
      <guid>https://wmatrix.github.io/post/orangepi-pc-plus-note/</guid>
      <description>本文主要是对在使用OrangePi PC Plus开发板的过程中遇到的一些问题的记录。
查看系统信息 由于移植的系统都是进行过裁剪的，所以很多在Linux中常用的工具命令可能都被删除掉了，从而查看一些系统的信息方式需要另找工具或者入口。特别是对于Android系统的使用上更是如此。以下是一些额外的途径去获取需要的系统信息。
 内核版本信息：uname 命令不存在时，可用 cat /proc/version 内存使用信息：free 命令不存在时，可用 cat /proc/meminfo 网络接口信息：ifconfig 命令不可用时, 可用 netcfg命令，或者 ip addr命令
root@dolphin-fvd-p1:/ # ip addr 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 16436 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 02:ae:79:67:9b:30 brd ff:ff:ff:ff:ff:ff inet 192.168.0.180/24 brd 192.168.0.255 scope global eth0 inet6 fe80::ae:79ff:fe67:9b30/64 scope link valid_lft forever preferred_lft forever 3: tunl0: &amp;lt;NOARP&amp;gt; mtu 1480 qdisc noop state DOWN link/ipip 0.</description>
    </item>
    
    <item>
      <title>FaceDetect算法对比测试</title>
      <link>https://wmatrix.github.io/post/facedetect%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Thu, 11 Jan 2018 11:53:58 -0800</pubDate>
      
      <guid>https://wmatrix.github.io/post/facedetect%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95/</guid>
      <description>测试说明 本对比测试使用不同的人脸检测算法对同样的两张图片样本进行检测：分别为单人和多人图片。
其中单人图片0_1_1.jpg大小为：550*694，多人图片children.jpg大小为：660*421.
通过对比各自算法在PC环境和Hi3519v101环境下的检测时间与检测准确率两项指标来评价算法的可行性。
测试结论 详细的测试步骤与输出信息见下面的测试环境结果，这里对这些信息进行简单的总结如下：
   算法/性能 PC Time(ms) 3519v101 Time(ms) PC Correct 3519v101 Correct     SeetaFaceEngine-FaceDet 235 3280 6 in 6 6 in 6   PICO - FaceDetetion 17 123 4 in 6 4 in 6   Opencv3.2 - HaarFrontalFace 170 2144 2 in 6 2 in 6   Opencv3.2 - LBPFrontalFace 70 213 1 in 6 1 in 6    注：PICO的性能在minsize和maxsize参数不同时，相差很大：</description>
    </item>
    
    <item>
      <title>麦克风阵列声源定位研究</title>
      <link>https://wmatrix.github.io/post/%E9%BA%A6%E5%85%8B%E9%A3%8E%E9%98%B5%E5%88%97%E5%A3%B0%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Tue, 09 Jan 2018 22:55:58 -0800</pubDate>
      
      <guid>https://wmatrix.github.io/post/%E9%BA%A6%E5%85%8B%E9%A3%8E%E9%98%B5%E5%88%97%E5%A3%B0%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%A0%94%E7%A9%B6/</guid>
      <description>阵列信号处理 空间谱估计理论
多重信号分类算法（MUSIC）应用 波达方向(DOA)估计的基本问题就是确定同时处在空间某一区域内多个感兴趣的信号的空间位置(即多个信号到达阵列参考阵元的方向角)。最早的也是最经典的超分辨DOA估计方法是著名的MUSIC方法，MUSIC是多重信号分类(Multiple Signal Classification)的英文缩写。它是由R.O.Schmidt于1979年提出来的，由1986年重新发表的。MUSIC算法利用了信号子空间和噪声子空间的正交性，构造空间谱函数，通过谱峰搜索，检测信号的DOA。
传统声源定位检测方法  基于可控波束形成器的声源定位：该方法对麦克风阵列接收到的语音信号进行滤波、加权求和，然后直接控制麦克风指向使波束有最大输出功率的方向; 基于高分辨率谱估计的定向技术：该方法利用求解麦克信号间的相关矩阵来定出方向角，从而进一步定出声源位置。 基于到达时间差(TDOA)技术：该方法首先求出声音到达不同位置麦克的时间差，再利用该时间差求得声音到达不同位置麦克的距离差，最后用搜索或几何知识确定声源位置。  基于可控波束形成的定位方法是出现比较早、并在实际中得到应用的一种定位方法。基于可控波束形成的定位主要分为延迟累加波束法和自适应波束法。前者运算量小，信号失真小，但抗噪性能低，需要较多的麦克才有比较好的效果。后者因为加了自适应滤波，所以运算量比较大，而且输出信号有一定程度的失真，但需要的麦克数目相对较少，在没有混响时有比较好的效果。基于到达时间差(TDOA)技术的定位方法运算量最小，原理简单，但是其需要得到声波到达各麦克风的精确的相位延迟，这对麦克风以及各输入和采集通道的性能一致性要求很高，不易实现。
声源定位技术在人工智能领域应用广泛，利用麦克风阵列来形成空间笛卡尔坐标系，根据不同的线性阵列，平面阵列和空间阵列，来确定声源在空间中的位置。了解声源定位技术之前，我们需要了解近场模型和远场模型。
通常麦克风阵列的距离为1~3m，阵列处于近场模型，麦克风阵列接受的是球面波而不是平面波，声波在传播的过程中会发生衰减，而衰减因子与传播的距离成正比，因此声波从声源到达阵元时候的幅度也各不相同。而远场模型中，声源到阵元的距离差相对较小，可以忽略。通常，我们定义2L²/λ为远近场临界值，L为阵列孔径，λ为声波波长，因此阵元接受信号不仅有相位延时还有幅度衰减。
麦克风阵列近场声源定位模型 利用麦克风阵列进行声源定位与传统的阵列信号处理理论所研究的对象信号最本质的区别是声音（语音）信号具有非平稳性，近场模型，和宽带信号这几个特点。 在近场情况下，必须采用精确的球面波前模型，来代替远场的平面波前模型。声波在传播过程中要发生幅度衰减，其幅度衰减因子与传播距离成正比。麦克风阵列的各个阵元到声源的距离是不同的，因此声波波前到达各个阵元时，幅度是不同的。近场模型和远场模型最主要的区别在于：是否考虑阵列的各个阵元因接收信号幅度衰减的不同所带来的影响。对于远场声源，麦克风阵元接收的信号之间幅度差别相对很小，可以忽略不计;但对于近场声源，麦克风阵元接收的信号之间幅度差别较大，必须予以考虑。
传统的阵列信号处理技术直接应用到麦克风阵列处理系统中往往效果不理想，其原因在于麦克风阵列处理有不同的处理特点：
 阵列模型的建立
麦克风主要应用处理语音信号，拾音范围有限，且多用于近场模型，使得常规的阵列处理方法如雷达，声呐等平面波远场模型不再适用，在近场模型中，需要更加精准的*球面波*，需要考虑传播路径不同引起的幅度衰减不同。
 宽带信号处理
通常的阵列信号处理多为窄带，即不同阵元在接受时延与相位差主要体现在载波频率，而语音信号未经过调制也没有载波，且高低频之比较大，不同阵元的相位延时与声源本身的特性关系很大—频率密切相关，使得传统的阵列信号处理方法不再完全适用。
 非平稳信号处理
传统阵列处理中，多为平稳信号，而麦克风阵列的处理信号多是非平稳信号，或者*短时平稳信号*，因此麦克风阵列一般对信号做短时频域处理，每个频域均对应一个相位差，将宽带信号在频域上分成多个子带，每个子带做窄带处理，再合并成宽带谱。
 混响
声音传播受空间影响较大，由于空间反射，衍射，麦克风收到的信号除了直达信号以外，还有*多径信号叠加*，使得信号被干扰，即为混响。在室内环境中，受房间边界或者障碍物衍射，反射导致声音延续，极大程度的影响语音的可懂度。
  阵列技术未来发展 麦克风阵列技术相对于单麦克风系统有很多优点，已成为语音增强及语音信号处理的重要部分。语音增强和声源定位已经成为阵列技术中不可缺少的部分，在视频会议，智能机器人，助听器，智能家电，通信，智能玩具，车载领域都需要声源定位和语音增强。各种信号处理技术，阵列信号处理技术都陆续结合到麦克风阵列的语音处理系统当中，并逐渐得到算法改进和进一步的广泛应用。在复杂的噪声环境，混响环境，声学环境下，强大的硬件处理能力也使得复杂算法实时处理语音增强成为了可能。在未来，语音和图像的紧密结合会成为人工智能领域的新的突破口，在人工智能的风口浪尖，是谁能将语音识别，语音理解，阵列信号处理，远场语音，图像识别，人脸识别，虹膜识别，声纹识别的技术巧妙并有机的结合在一起，并将技术的本质和与人为本的宗旨完美的结合，让我们拭目以待。
谱抵消去噪及语音检测 由于麦克风的拾音范围有限，当声源离阵列较远时，麦克风采集到的信号较弱，这时就需要对信号进行放大。但是，在信号放大的同时，背景噪声也被放大了。这样，阵列采集到的信号质量很差，算法处理的效果会受到影响，因此，需要先进行预处理，去背景噪声。而且，在使用麦克风阵列处理各帧采样数据时，该帧数据中是否含有语音信号所需的运算量相差很大。如果不加区别，则严重影响了算法的实时性，浪费了系统资源。因此，对采样数据进行语音检测非常必要。因此本节重点讲述在进行声源定位算法实施前，对采集到的语音信号的必要的预处理过程：即谱抵消去噪及语音检测。
谱抵消去噪  当阵列收到一帧数据x[n],n=1,2，…，fLen之后，fLen定义的帧长，首先对该帧信号进行短时傅里叶变换(STFT)，得到频域值X[k,t]，k=1,2，…，fLen，τ为短时傅里叶变换的时间参数。 接着根据X[k,t]进行判断，如果max{X[k,t]}&amp;lt;=threshold，或者超过threshold的频率不在语音范围之内，则认为本帧为噪声帧，否则为语音帧，其中threshold为一门限值，它的值既可以根据经验事先设定，也可以由具体环境来确定。 如果本帧数据为噪声，则更新噪声幅度谱的值，也就是使噪声幅度谱始终保持为最近的噪声偏置;如果本帧数据为语音，则用接收信号的幅度谱在频域减去噪声幅度谱，即以最近的噪声模拟当前的噪声，从而去除背景噪声，得到降噪后的信号幅度谱。  谱抵消技术能够用于去处背景噪声，提高语音检测算法的准确率，但在应用中需要注意两点： 1. 噪声和语音信号在评语重叠很厉害，单靠谱抵消算法从本质上来说无法有效去噪。 2. 考虑到实时性，过于复杂的谱抵消会影响系统的实时性。
语音检测VAD（Video Activity Detection） VAD技术广泛地应用于各种语音处理系统中，语音识别过程需要进行起止点判决，语音增强算法要求从含噪语音中提取噪声进行统计，语音编码可以利用“语音插空”以增加信道容量。这些都离不开VAD技术。在许多实际应用中，首先应用VAD之后，使得后续处理只需针对语音段进行，减少了无谓的计算量和数据量，提高了与用户的实时交互性。
语音检测VAD算法有很多种，但是其大致可分为两类： * 基于语音与噪声的统计信息的自适应检测方法
自适应检测方法虽然适应性广，但需要事先对语音和噪声模型进行训练以得到背景噪声和语音的统计信息，而且大部分算法要求背景噪声保持平稳，信噪比要求较高。但是实际环境中很难满足这些条件。另外，自适应检测算法实现起来耗时多，不易实时实现。
 基于固定检测条件的非自适应检测方法  非自适应检测方法的基本思想是从输入信号中提取一些度量特征值，再与相应的门限值进行比较。VAD算法一般都以帧为单位，逐帧进行判断，每帧的长度为20-40ms门限值一般是从单纯的噪声中获取的。若计算得到的度量值大于门限，则为有音帧(活动帧)，否则为无音帧(非活动帧)，因此这类方法也可称之为阈值比较法。这类算法关键是如何选择度里特征值，以及如何定义和更新门限。一个好的VAD算法应该具有简单、自适应、对噪声环境的鲁棒性以及能够实时处理等特点。
语音信号分析 时域特征分析  短时能量与短时平均幅度
主要用途在于浊音段与清音段，因为浊音时短时能量比清音时大很多；区分声母和韵母的分界，以及有话段与无话段的分界。
 短时平均过零率
表示一帧语音信号中语音数据穿过横轴（零电平）的次数。对于离散信号，如果相邻的采样值符号改变，则成为过零。短时平均过零率就是样本值符号改变的次数。
  浊音具有较低的频率，因而相对具有较低的过零率；清音具有较高的频率，因而具有较高的过零率。利用短时平均过零率，可以从背景噪声中找出语音信号。在背景噪声较小时，使用短时能量与短时平均幅度识别较为有效；而在背景噪声较大时，用短时过零率识别较为有效。</description>
    </item>
    
    <item>
      <title>Hello Hugo</title>
      <link>https://wmatrix.github.io/post/first/</link>
      <pubDate>Tue, 09 Jan 2018 22:53:58 -0800</pubDate>
      
      <guid>https://wmatrix.github.io/post/first/</guid>
      <description>Hello Hugo  aaa bbb ccc  Markdowm Usage 使用markdowm的语法添加图片和引用的方法：</description>
    </item>
    
    <item>
      <title>嵌入式视觉应用与方案</title>
      <link>https://wmatrix.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A7%86%E8%A7%89%E5%BA%94%E7%94%A8%E4%B8%8E%E6%96%B9%E6%A1%88/</link>
      <pubDate>Tue, 09 Jan 2018 22:53:58 -0800</pubDate>
      
      <guid>https://wmatrix.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A7%86%E8%A7%89%E5%BA%94%E7%94%A8%E4%B8%8E%E6%96%B9%E6%A1%88/</guid>
      <description> 嵌入式视觉解决方案 软件与硬件全面结合的整体解决方案上游提供商：
 Intel Altera SoC FPGA： Intelligent Vision &amp;amp; Video Xilinx All Programmable SoC： Embedded Vision reVision  视频监控  Altera Cyclone IV FPGA： 机器视觉方案 Altera Cyclone V SoC : FPGA + ARM Cortex-A9  FPGA与VHDL  模拟模型： 模拟软件，目前常用的VHDL模拟软件有ActiveHDL和Modelsim。 综合模型： 综合软件，目前常用的综合软件有Synplicity公司的Synplify和SynplifyPro软件  VHDL仿真Simulation 不适用真实硬件系统的情况下，使用计算机软件对VHDL设计的电路系统进行功能验证与测试
 功能仿真： 未经布线与适配 时序仿真： 经过布线与适配后，芯片仿真  VHDL综合 把VHDL描述转化为门级电路描述，设计过程中的每一步都可称为一个综合环节。
 自然语言综合：从自然语言转换到VHDL语言算法表示 行为综合：从算法表示转换到寄存器传输级(Register Transport Level,RTL),即从行为域到结构域的综合。 逻辑综合：RTL级表示转换到逻辑门的表示 版图综合：从逻辑门表示转换到版图表示(ASIC设计)，或转换到FPGA的配置网表文件。有了版图信息就可以把芯片生产出来了。有了对应的配置文件，就可以使对应的FPGA变成具有专门功能的电路器件。  </description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://wmatrix.github.io/about/</link>
      <pubDate>Tue, 09 Jan 2018 22:53:33 -0800</pubDate>
      
      <guid>https://wmatrix.github.io/about/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>